# Auto-synced file, managed by [dealroom/mothership](https://github.com/dealroom/mothership)
# The changes to this file will be automatically overwritten on the next sync. Do not edit by hand!

name: Automerge Wait for Reviews
description: Wait for code review bots to complete their analysis
inputs:
  github-token:
    description: GitHub token for API access
    required: true
  bot-usernames:
    description: Comma-separated list of bot usernames to wait for
    required: false
    default: "copilot-pull-request-reviewer[bot],cursor[bot]"
  bot-check-names:
    description: Comma-separated list of bot check names/patterns to wait for
    required: false
    default: "cursor,copilot"
  timeout-seconds:
    description: Maximum time to wait for bot reviews (in seconds)
    required: false
    default: "300"
  poll-interval-seconds:
    description: Time between polling attempts (in seconds)
    required: false
    default: "5"
outputs:
  bots-reviewed:
    description: Comma-separated list of bots that have reviewed (includes both GitHub usernames and app slugs/check names; identifier types may be mixed)
    value: ${{ steps.wait-for-reviews.outputs.bots-reviewed }}
  pending-checks:
    description: Comma-separated list of pending bot checks (if timeout)
    value: ${{ steps.wait-for-reviews.outputs.pending-checks }}
runs:
  using: composite
  steps:
    - uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
      id: wait-for-reviews
      with:
        github-token: ${{ inputs.github-token }}
        script: |
          const owner = context.repo.owner;
          const repo = context.repo.repo;
          const pull_number = context.payload.pull_request ? context.payload.pull_request.number : context.issue.number;

          // Parse inputs
          const botUsernames = '${{ inputs.bot-usernames }}'.split(',').map(s => s.trim());
          const botCheckNames = '${{ inputs.bot-check-names }}'.split(',').map(s => s.trim().toLowerCase());
          const timeoutSeconds = parseInt('${{ inputs.timeout-seconds }}');
          const pollIntervalSeconds = parseInt('${{ inputs.poll-interval-seconds }}');

          // Define pending statuses
          const PENDING_STATUSES = ['queued', 'in_progress', 'requested', 'waiting', 'pending'];

          // Helper function to check if a check run is from a bot
          const isBotCheck = (check) => {
            const checkNameLower = check.name.toLowerCase();
            const appSlugLower = (check.app?.slug || '').toLowerCase();

            return botCheckNames.some(botName =>
              checkNameLower.includes(botName) || appSlugLower.includes(botName)
            );
          };

          // Helper function to check if a check run is a pending bot check
          const isPendingBotCheck = (check) => {
            const isPending = PENDING_STATUSES.includes(check.status);
            return isBotCheck(check) && isPending;
          };

          // Helper function to get elapsed seconds
          const getElapsedSeconds = () => Math.floor((Date.now() - startTime) / 1000);

          // Helper function to filter completed bot check runs
          const getCompletedBotCheckRuns = (checkRuns) => {
            return checkRuns.filter(check =>
              isBotCheck(check) && check.status === 'completed'
            );
          };

          // Helper function to combine bot arrays from different sources
          const combineBotArrays = (reviewBots, checkBots) => {
            return [
              ...Array.from(reviewBots), // Bot usernames from reviews/comments
              ...Array.from(checkBots)    // App slugs from CI checks
            ];
          };

          // Helper function to track completed bot checks
          const trackCompletedBotChecks = (checkRuns, checkBots) => {
            const completedBotCheckRuns = getCompletedBotCheckRuns(checkRuns);
            for (const check of completedBotCheckRuns) {
              if (check.app?.slug) {
                checkBots.add(check.app.slug);
              }
            }
          };

          const startTime = Date.now();
          const maxWaitTime = timeoutSeconds * 1000;
          const pollInterval = pollIntervalSeconds * 1000;
          // Track bots separately by identifier type:
          // - foundReviewBots: GitHub usernames from reviews/comments (e.g., "copilot-pull-request-reviewer[bot]")
          // - foundCheckBots: App slugs from CI checks (e.g., "github-actions", "cursor")
          // This separation ensures that each bot is identified consistently according to its source (review/comment vs CI check),
          // and avoids mixing usernames with app slugs, which are distinct identifier types.
          const foundReviewBots = new Set(); // Bot usernames from reviews/comments
          const foundCheckBots = new Set();  // App slugs from CI checks

          // Get PR details for head SHA
          const { data: pr } = await github.rest.pulls.get({
            owner,
            repo,
            pull_number
          });

          // Polling loop
          while (Date.now() - startTime < maxWaitTime) {
            const elapsedSeconds = getElapsedSeconds();
            // First check for pending bot CI checks
            const { data: checkRuns } = await github.rest.checks.listForRef({
              owner,
              repo,
              ref: pr.head.sha,
              per_page: 100
            });

            const pendingBotChecks = checkRuns.check_runs.filter(isPendingBotCheck);
            // Track completed bot checks
            trackCompletedBotChecks(checkRuns.check_runs, foundCheckBots);

            if (pendingBotChecks.length > 0) {
              const pendingNames = pendingBotChecks.map(c => c.name).join(', ');
              console.log(`[${elapsedSeconds}s] Waiting for: ${pendingNames}`);
              await new Promise(resolve => setTimeout(resolve, pollInterval));
              continue;
            }

            // Get all reviews
            const reviews = await github.paginate(
              github.rest.pulls.listReviews,
              {
                owner,
                repo,
                pull_number
              }
            );

            for (const review of reviews) {
              if (review.user && botUsernames.includes(review.user.login)) {
                foundReviewBots.add(review.user.login);
              }
            }

            const comments = await github.paginate(
              github.rest.issues.listComments,
              {
                owner,
                repo,
                issue_number: pull_number
              }
            );

            for (const comment of comments) {
              if (comment.user && botUsernames.includes(comment.user.login)) {
                foundReviewBots.add(comment.user.login);
              }
            }

            const reviewComments = await github.paginate(
              github.rest.pulls.listReviewComments,
              {
                owner,
                repo,
                pull_number
              }
            );

            for (const comment of reviewComments) {
              if (comment.user && botUsernames.includes(comment.user.login)) {
                foundReviewBots.add(comment.user.login);
              }
            }

            const totalBotsFound = foundReviewBots.size + foundCheckBots.size;
            if (totalBotsFound > 0 && pendingBotChecks.length === 0) {
              // Format output with consistent identifiers
              const allBots = combineBotArrays(foundReviewBots, foundCheckBots);
              console.log(`[${elapsedSeconds}s] All checks complete. Bots: ${allBots.join(', ')}`);
              core.setOutput('bots-reviewed', allBots.join(', '));
              core.setOutput('pending-checks', '');
              return;
            }

            await new Promise(resolve => setTimeout(resolve, pollInterval));
          }

          console.log(`[${timeoutSeconds}s] Timeout reached`);

          const { data: finalCheckRuns } = await github.rest.checks.listForRef({
            owner,
            repo,
            ref: pr.head.sha,
            per_page: 100
          });

          const pendingChecks = finalCheckRuns.check_runs.filter(isPendingBotCheck);
          // Track final completed bot checks
          trackCompletedBotChecks(finalCheckRuns.check_runs, foundCheckBots);

          const pendingCheckNames = pendingChecks.map(c => c.name);
          // Format final output with all found bots
          const allBots = combineBotArrays(foundReviewBots, foundCheckBots);
          core.setOutput('bots-reviewed', allBots.join(', '));
          core.setOutput('pending-checks', pendingCheckNames.join(', '));
